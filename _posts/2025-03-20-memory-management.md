---
layout: post
title: CPU及内存调度（二） -- Linux内存管理
categories: CPU及内存调度
tags: 内存
---

* content
{:toc}

CPU和内存调度相关学习实践系列，本篇梳理Linux内存管理及相关的进程、线程创建。



## 1. 背景

在[CPU及内存调度（一） -- 进程、线程、系统调用、协程上下文切换](https://xiaodongq.github.io/2025/03/09/context-switch)中已经介绍过Linux通过页表机制进行内存映射管理，涉及TLB、MMU、缺页中断等，并发与异步编程系列梳理学习中，也涉及内存序和CPU缓存等问题，本篇开始梳理学习Linux内存管理，以及相关的进程、线程创建过程。

主要参考：

* [一步一图带你深入理解 Linux 虚拟内存管理](https://mp.weixin.qq.com/s/uWadcBxEgctnrgyu32T8sQ)
* [一步一图带你深入理解 Linux 物理内存管理](https://mp.weixin.qq.com/s/Cn-oX0W5DrI2PivaWLDpPw)
* 以及进程创建流程相关文章：
    * [Linux进程是如何创建出来的？](https://mp.weixin.qq.com/s/ftrSkVvOr6s5t0h4oq4I2w)
    * [进程和线程之间有什么根本性的区别？](https://mp.weixin.qq.com/s/--S94B3RswMdBKBh6uxt0w)

上述参考文章内容写得很好，由浅入深介绍内存结构、内存管理，并跟踪相关内核代码进行说明，其中用exclidraw画的配图也很直观。本篇博客中的配图，若无特别出处备注，均出自参考文章。

*说明：本博客作为个人学习实践笔记，可供参考但非系统教程，可能存在错误或遗漏，欢迎指正。若需系统学习，建议参考原链接。*

## 2. 进程虚拟内存空间结构

Linux为每个进程分配独立的虚拟内存，各进程间有独立的虚拟地址空间，使用内存时相互隔离。相对于直接使用物理内存，极大扩展了可用空间。

进程在其内存地址空间中的资源访问，由TLB和MMU等组件，映射到真正的物理内存上。虽然虚拟地址可能相同，但实际读写的物理地址是不同的。如下图所示：

![virutal-memory-map](/images/virutal-memory-map.png)

**进程虚拟内存空间的结构：**

代码编译成二进制文件后，需要加载到内存中才能运行。对于32位和64位操作系统，加载到内存中时的结构除了虚拟地址空间大小差异外，其他结构基本类似。

虚拟地址空间从低地址到高地址，组成依次为：**代码段（Text Segment）** -> **数据段（Data Segment）** -> **BSS段（Block Started by Symbol ）** -> **堆（Heap）** -> **栈（Stack）**，再往上是**内核态空间**。且对于64位系统，由于只使用**48位**来描述虚拟内存空间，用户态空间和内核态之间还有一层`canonical address 空洞`。

1、`32位`系统 -- 进程虚拟内存空间结构示意图：

![virtual-memory-struct-32bit](/images/virtual-memory-struct-32bit.png)

说明：

* 32位系统上，指针寻址范围`2^32`，对应虚拟内存空间`4GB`，其中用户态`3GB`，内核态`1GB`
* **保留区**：0x0000 0000 到 `0x0804 8000` 这段虚拟内存地址是一段不可访问的保留区
* 编译器确定：
    * **代码段**存储二进制文件中的机器码、**数据段**存储指定了初始值的 全局变量和静态变量、**BSS段**存储未指定初始值的全局变量和静态变量
* 运行器确定：
    * **堆**存储动态的申请内存
    * **文件映射与匿名映射区**，用于存储：
        * 1）程序运行依赖的动态链接库，这些动态链接库也有自己的对应的代码段，数据段，BSS 段，加载到内存需要的空间
        * 2）内存文件映射的系统调用`mmap`，映射的内存空间
    * **栈**，存储程序运行期间，函数调用过程中用到的局部变量和参数
* 注意几个分段的**地址增长方向**
    * 堆：从低地址到高地址增长
    * 文件映射与匿名映射区：从高地址到低地址增长
    * 栈：从高地址到低地址增长

2、`64位`系统 -- 进程虚拟内存空间结构示意图：

![virtual-memory-struct-64bit](/images/virtual-memory-struct-64bit.png)

* `64位`系统上，只用了48位来表示虚拟内存地址，即`2^48`，`256TB`，用户态和内核态虚拟内存空间各128TB
    * 低128T 的用户态虚拟内存空间，高16位全部为 **0**，高128T 的内核态虚拟内存空间，高16位全部为 **1**
    * 所以根据`高16位`，可以快速判断地址是内核态还是用户态地址
* 和32位系统的不同
    * 高16位空闲地址造成了 `canonical address 空洞`，在这段范围内的虚拟内存地址是不合法的
    * 代码段跟数据段的中间还有一段不可以读写的保护段，防止程序在读写数据段的时候越界访问到代码段，可让越界时直接崩溃，防止它继续往下运行
    * 空间大小不同

详细说明可见参考链接。

## 3. 内核的进程空间管理

既然说进程的虚拟内存空间管理，那就离不开进程的创建。下面先看下内核中创建进程的简要流程，再跟进其中涉及的内存管理相关结构和机制。

### 3.1. 内核创建进程

结合 [Linux进程是如何创建出来的？](https://mp.weixin.qq.com/s/ftrSkVvOr6s5t0h4oq4I2w) 和 [进程和线程之间有什么根本性的区别？](https://mp.weixin.qq.com/s/--S94B3RswMdBKBh6uxt0w) 一起梳理。

进程的核心结构：`task_struct`

```cpp

```


## 4. 小结


## 5. 参考

* [一步一图带你深入理解 Linux 虚拟内存管理](https://mp.weixin.qq.com/s/uWadcBxEgctnrgyu32T8sQ)
* [一步一图带你深入理解 Linux 物理内存管理](https://mp.weixin.qq.com/s/Cn-oX0W5DrI2PivaWLDpPw)
* [Linux进程是如何创建出来的？](https://mp.weixin.qq.com/s/ftrSkVvOr6s5t0h4oq4I2w)
* [进程和线程之间有什么根本性的区别？](https://mp.weixin.qq.com/s/--S94B3RswMdBKBh6uxt0w)
