---
layout: post
title: 并发与异步编程（二） -- 异步编程框架了解
categories: 并发与异步编程
tags: CPU 存储 异步编程
---

* content
{:toc}

异步编程学习实践系列，介绍几种异步编程框架，并简要学习基本原理。



## 1. 背景

[并发与异步编程（一） -- 实现一个简单线程池](https://xiaodongq.github.io/2025/03/08/threadpool/) 中，实现了一个基本的线程池，当时的异步编程实现还留了一个TODO。

本篇先学习异步编程的几个框架和基本原理，后续进行编程实践和性能观察对比。

主要学习了解异步编程相关的：**Linux aio**、**io_uring**、**SPDK**、C++的**std::async**、Boost.Asio

参考：

* [[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）](https://arthurchiao.art/blog/intro-to-io-uring-zh/)
* [浅析开源项目之io_uring](https://zhuanlan.zhihu.com/p/361955546)
* [Linux原生异步IO原理与实现（Native AIO）](https://zhuanlan.zhihu.com/p/364819119)
* [spdk doc](https://spdk.io/doc/)
* [cppreference std::async](https://en.cppreference.com/w/cpp/thread/async)
* [Boost.Asio C++ 网络编程](https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html)

*说明：本博客作为个人学习实践笔记，可供参考但非系统教程，可能存在错误或遗漏，欢迎指正。若需系统学习，建议参考原链接。*

## 2. 总体说明

借着 [[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）](https://arthurchiao.art/blog/intro-to-io-uring-zh/) 中的Linux I/O系统调用演进说明，引入异步IO。

Linux I/O系统调用演进：

* 1、基于fd的阻塞式 I/O：`read()`/`write()`
    * fd可指向本地文件（**storage files**）、也可指向网络socket（**network sockets**）
    * 皆为阻塞式系统调用（blocking system calls）
* 2、非阻塞式 I/O：`select()`/`poll()`/`epoll()`
    * 只支持 网络sockets 和 pipes管道
    * epoll也并不是异步网络IO，epoll回调事件通知，具体的读写操作仍然需要用户去做，而不是内核代替完成
* 3、线程池方式
    * storage I/O，经典解决思路是线程池。主线程将 I/O 分发给 worker 线程，worker中阻塞式读写
    * 问题是 线程上下文切换开销可能非常大
* 4、Direct I/O
    * 数据库软件（database software）有时不想用系统的page cache，而是自己管理缓存，会使用直接IO
    * 设置`O_DIRECT`选项。
        * 之前在 [学习Linux存储IO栈（三） -- eBPF和ftrace跟踪IO写流程](https://xiaodongq.github.io/2024/08/15/linux-write-io-stack/) 中也做过直接IO实验，需要保证申请的空间和系统blocksize对齐（`posix_memalign`），且`write`时长度也须为blocksize整数倍。
        * 现代盘的blocksize一般为4KB，可`blockdev --getbsz /dev/nvme0n1`查看，我PC的盘就是4096（传统盘可能为512字节）
* 5、**异步 IO（AIO）**
    * 随着存储设备越来越快，主线程和 worker 线性之间的上下文切换开销占比越来越高。
        * 市场上有些设备，延迟已经低到和上下文切换一个量级（微秒 us），意味着上下文每切换一次，我们就少一次 `dispatch` I/O 的机会
        * 比如 [Intel Optane](https://pcper.com/2018/12/intels-optane-dc-persistent-memory-dimms-push-latency-closer-to-dram/)
    * 因此，Linux 2.6 内核引入了异步 I/O（asynchronous I/O）接口：`Linux AIO`。
        * 基本原理：1）通过`io_submit()`提交 I/O 请求 2）后续`io_getevents()`检查哪些 events 已经 ready 了
    * 对于block层的调度，`bio`进入`request`（简称`rq`）队列后，设备驱动程序拉取一个rq存到`dispatch`队列，而后封装成`cmd`（比如scsi_cmnd）
        * 可参考 [学习Linux存储IO栈（四） -- 通用块层](https://xiaodongq.github.io/2024/08/26/linux-io-stack-block/) 里梳理的流程
    * 但是，Linux AIO有不少问题：只支持`O_DIRECT`文件、接口设计未考虑扩展性、很多可能的原因会导致阻塞，可了解：[Linux kernel AIO这个奇葩](https://www.aikaiyuan.com/4556.html)

> Linux迫切需要一个完善的异步机制。同时在Linux平台上跑的大多数程序都是专用程序，并不需要内核的大多数功能，而且这几年也流行kernel bypass，intel也发起的用户态IO DPDK、SPDK。但是这些用户态IO API不统一，使用成本过高，所以内核便推出了io_uring来统一网络和磁盘的异步IO，提供一套统一完善的异步API，也支持异步、轮询、无锁、zero copy。  
> 见：[浅析开源项目之io_uring](https://zhuanlan.zhihu.com/p/361955546)。

## 3. Linux AIO

先了解Linux原生（Native）的AIO处理流程。加`原生`是因为Linux存在很多第三方异步IO库，如 `libeio` 和 `glibc AIO`，所以为了加以区别，Linux内核提供的异步IO就称为 `原生异步IO`。

很多第三方的异步IO库都不是真正的异步IO，而是使用多线程来模拟异步IO，如 libeio 就是使用多线程来模拟异步IO的。

异步IO流程示意图：

![linux aio](/images/linux_aio.jpg)  

上图流程说明：

* 当应用程序调用 `io_submit` 系统调用发起一个异步 IO 操作后，会向内核的 IO 任务队列中添加一个 IO 任务，并且返回成功
* 内核会在后台处理 IO 任务队列中的 IO 任务，然后把处理结果存储在 IO 任务中
* 应用程序可以调用 `io_getevents` 系统调用来获取异步 IO 的处理结果，如果 IO 操作还没完成，那么返回失败信息，否则会返回 IO 处理结果

API（具体实现源码在fs/aio.c中）使用步骤：

* 1、调用 `io_setup` 函数创建一个异步 IO 上下文
    * `struct kioctx`结构来表示上下文，其中的`ring_info`成员是一个环形缓冲区（Ring Buffer），用于存放异步IO操作的结果
* 2、调用 `io_submit` 函数向内核提交一个异步 IO 操作
* 3、调用 `io_getevents` 函数获取异步 IO 操作结果

参考：[Linux原生异步IO原理与实现（Native AIO）](https://zhuanlan.zhihu.com/p/364819119)

## 4. io_uring

### 4.1. 基本介绍

io_uring的作者是 [Jens Axboe](https://en.wikipedia.org/wiki/Jens_Axboe)，同时也是`fio`、`blktrace`的作者。

io_uring的高性能依赖以下几个方面：

* 用户态和内核态共享`提交队列（SQ，submission queue）`和`完成队列（CQ，completion queue）`
    * 两个队列都是单生产者、单消费者；
    * 队列提供`无锁接口`（lock-less access interface），内部使用`内存屏障`（memory barriers）做同步
* 用户态支持Polling模式，不依赖硬件的中断，通过调用`IORING_ENTER_GETEVENTS`不断轮询收割（reap）完成事件
* 内核态支持Polling模式，IO 提交和收割可以 offload 给 Kernel，且提交和完成不需要经过系统调用（system call）
* 在Direct I/O下可以提前注册用户态内存地址，减小地址映射的开销

io_uring 实例支持三种工作模式：

* 中断驱动模式（interrupt driven），也是默认模式
* 轮询模式（polled）
* 内核轮询模式（kernel polled）

### 4.2. 使用流程简要说明

SQ、CQ队列示意图如下：  
![io_uring](/images/io_uring.png)  
[参考]((https://arthurchiao.art/blog/intro-to-io-uring-zh/))

使用流程：

* 请求
    * 应用创建 SQ entries (`SQE`)，更新 SQ tail
    * 内核消费 `SQE`，更新 SQ head
* 完成
    * 内核为完成的一个或多个请求创建 CQ entries (`CQE`)，更新 CQ tail
    * 应用消费 `CQE`，更新 CQ head

io_uring提供了3个系统调用API：

* `io_uring_setup`
    * 执行异步 I/O 需要先设置上下文，该接口创建一个 `SQ` 和一个 `CQ`
    * SQ 和 CQ 在应用和内核之间共享，避免了在初始化和完成 I/O 时（initiating and completing I/O）拷贝数据
    * 函数声明：int io_uring_setup(u32 entries, struct io_uring_params *p);
* `io_uring_register`
    * 注册文件或用户缓冲区（files or user buffers）
    * int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args);
* `io_uring_enter`
    * 用于初始化和完成（initiate and complete）I/O，使用共享的 `SQ` 和 `CQ`
    * io_uring_enter即可以提交I/O，也可以来收割完成的I/O，一般I/O完成时内核会自动将`SQE` 的索引放入到CQ中，用户可以遍历`CQ`来处理完成的IO
    * int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);

[man手册](https://github.com/axboe/liburing/tree/master/man)

### 4.3. liburing

io_uring虽然仅提供了3个系统API，但是用起来还是比较复杂的，所以io_uring作者封装了一个`liburing`，简化了io_uring的使用。

## 5. SPDK

## 6. C++中的异步编程组件

### 6.1. std::async

### 6.2. Boost.Asio

## 7. 小结


## 8. 参考

* [[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）](https://arthurchiao.art/blog/intro-to-io-uring-zh/)
* [浅析开源项目之io_uring](https://zhuanlan.zhihu.com/p/361955546)
* [Linux原生异步IO原理与实现（Native AIO）](https://zhuanlan.zhihu.com/p/364819119)
